<?xml version="1.0" encoding="UTF-8"?>
<!--
  ============================================================
  OMEGA GITHUB PUBLISHING PROTOCOL
  ============================================================
  VERSION:      1.0
  STATUS:       LAW
  PURPOSE:      Defines the rules, workflows, and safety checks
                for publishing projects to GitHub.
                Governs multi-repo sync, commit standards,
                and release management.

  USAGE:        This protocol is CONFIGURABLE. Users must define
                their own repositories in the <user_config> section
                or in a separate publish.config.json file.
  ============================================================
-->

<github_publishing
  version="1.0"
  status="LAW"
  location="constitution/">

  <!-- ============================================================
       PART 1: USER CONFIGURATION

       INSTRUCTIONS: Replace placeholder values with your own
       repository details. This config can also be stored in
       a separate publish.config.json file.
  ============================================================ -->

  <user_config>
    <description>
      Configure your project's GitHub repositories here.
      The omega-publish.py script will read this configuration.
    </description>

    <!-- EXAMPLE CONFIGURATION - REPLACE WITH YOUR OWN -->
    <repositories>
      <!--
        For each repository, define:
        - name: Human-readable name
        - local_path: Path relative to your project root
        - remote_url: Your GitHub repository URL
        - branch: Target branch (usually "main")
      -->

      <repo name="my-project" primary="true">
        <local_path>./src</local_path>
        <remote_url>https://github.com/YOUR_USERNAME/YOUR_REPO.git</remote_url>
        <branch>main</branch>
      </repo>

      <!-- Add more repos if you have a multi-repo architecture -->
      <!--
      <repo name="my-docs">
        <local_path>./docs</local_path>
        <remote_url>https://github.com/YOUR_USERNAME/YOUR_DOCS_REPO.git</remote_url>
        <branch>main</branch>
      </repo>
      -->
    </repositories>

    <!-- Optional: Define environment-specific configs -->
    <environments>
      <env name="development" branch="dev"/>
      <env name="staging" branch="staging"/>
      <env name="production" branch="main"/>
    </environments>
  </user_config>

  <!-- ============================================================
       PART 2: PUBLISH WORKFLOW
  ============================================================ -->

  <publish_workflow>
    <description>
      Standard workflow for publishing code to GitHub.
    </description>

    <steps>
      <step order="1" name="Pre-Publish Checks">
        Run validation checks before publishing (see checklist below)
      </step>
      <step order="2" name="Stage Changes">
        Review and stage files for commit
      </step>
      <step order="3" name="Commit">
        Create commit with standardized message format
      </step>
      <step order="4" name="Push">
        Push to remote repository
      </step>
      <step order="5" name="Verify">
        Confirm push succeeded and check CI/CD status
      </step>
    </steps>

    <automation_script>
      <name>omega-publish.py</name>
      <location>python/omega-publish.py</location>
      <usage>
        <command>python omega-publish.py "Your commit message"</command>
        <command>python omega-publish.py --config publish.config.json "Message"</command>
        <command>python omega-publish.py --dry-run "Test message"</command>
      </usage>
    </automation_script>
  </publish_workflow>

  <!-- ============================================================
       PART 3: COMMIT STANDARDS
  ============================================================ -->

  <commit_standards>
    <description>
      All commits must follow these standards for clarity and traceability.
    </description>

    <message_format>
      <pattern>[type]: [Brief description]</pattern>
      <max_length>72 characters for first line</max_length>
      <body_format>
        Optional extended description after blank line.
        Explain WHY, not just WHAT.
      </body_format>
    </message_format>

    <commit_types>
      <type name="feat" description="New feature or capability"/>
      <type name="fix" description="Bug fix or error correction"/>
      <type name="docs" description="Documentation changes only"/>
      <type name="style" description="Formatting, no code change"/>
      <type name="refactor" description="Code restructuring without behavior change"/>
      <type name="test" description="Adding or updating tests"/>
      <type name="chore" description="Maintenance, dependencies, build"/>
      <type name="security" description="Security-related changes"/>
      <type name="perf" description="Performance improvements"/>
    </commit_types>

    <examples>
      <example>feat: Add user authentication system</example>
      <example>fix: Resolve race condition in data sync</example>
      <example>docs: Update API documentation for v2</example>
      <example>refactor: Extract validation logic to separate module</example>
      <example>security: Sanitize user input on form submission</example>
    </examples>

    <forbidden_messages>
      <forbidden>"WIP" or "Work in progress" - commits should be complete</forbidden>
      <forbidden>"Fix stuff" or vague descriptions</forbidden>
      <forbidden>Single character or empty-like messages</forbidden>
      <forbidden>Messages without type prefix</forbidden>
    </forbidden_messages>
  </commit_standards>

  <!-- ============================================================
       PART 4: PRE-PUBLISH CHECKLIST
  ============================================================ -->

  <pre_publish_checklist>
    <description>
      MANDATORY checks before publishing to GitHub.
    </description>

    <category name="Security">
      <item required="true">No API keys, secrets, or credentials in staged files</item>
      <item required="true">No .env files being committed (check .gitignore)</item>
      <item required="true">No private/sensitive data exposed</item>
    </category>

    <category name="Code Quality">
      <item required="true">Code compiles/runs without errors</item>
      <item required="true">Tests pass (if applicable)</item>
      <item required="true">No debug statements or console.logs left in</item>
      <item required="false">Linter passes (recommended)</item>
    </category>

    <category name="Files">
      <item required="true">Only intended files are staged</item>
      <item required="true">No IDE config files (.idea, .vscode) unless intentional</item>
      <item required="true">No OS files (.DS_Store, Thumbs.db)</item>
      <item required="true">No build artifacts (node_modules, __pycache__, dist/)</item>
    </category>

    <category name="Documentation">
      <item required="false">README updated if features changed</item>
      <item required="false">CHANGELOG updated for releases</item>
      <item required="false">API docs updated if endpoints changed</item>
    </category>

    <validation_commands>
      <command purpose="Find secrets" lang="bash">
        grep -rn "API_KEY\|SECRET\|PASSWORD\|TOKEN" --include="*.py" --include="*.js" --include="*.ts"
      </command>
      <command purpose="Check Python syntax" lang="bash">
        python -m py_compile *.py
      </command>
      <command purpose="Check staged files" lang="bash">
        git diff --cached --name-only
      </command>
      <command purpose="Dry run" lang="bash">
        python omega-publish.py --dry-run "Test"
      </command>
    </validation_commands>
  </pre_publish_checklist>

  <!-- ============================================================
       PART 5: BRANCH MANAGEMENT
  ============================================================ -->

  <branch_management>
    <description>
      Recommended branch strategy for projects using this protocol.
    </description>

    <strategies>
      <strategy name="Simple" recommended_for="Small projects, solo developers">
        <branch name="main" role="Production">All stable code</branch>
        <workflow>Commit directly to main, or use short-lived feature branches</workflow>
      </strategy>

      <strategy name="GitFlow" recommended_for="Teams, versioned releases">
        <branch name="main" role="Production">Release-ready code only</branch>
        <branch name="develop" role="Integration">Features merged here first</branch>
        <branch name="feature/*" role="Development">Individual features</branch>
        <branch name="release/*" role="Staging">Release preparation</branch>
        <branch name="hotfix/*" role="Emergency">Production fixes</branch>
      </strategy>

      <strategy name="Trunk-Based" recommended_for="CI/CD, frequent deploys">
        <branch name="main" role="Trunk">All development happens here</branch>
        <branch name="release/*" role="Releases">Cut from main when needed</branch>
        <workflow>Short-lived branches, frequent merges to main</workflow>
      </strategy>
    </strategies>

    <rules>
      <rule>Never force-push to main/master without team agreement</rule>
      <rule>Delete branches after merging</rule>
      <rule>Use descriptive branch names: feature/add-auth, fix/login-bug</rule>
    </rules>
  </branch_management>

  <!-- ============================================================
       PART 6: RELEASE MANAGEMENT
  ============================================================ -->

  <release_management>
    <description>
      Protocol for versioned releases.
    </description>

    <versioning>
      <scheme name="Semantic Versioning" pattern="MAJOR.MINOR.PATCH">
        <major>Breaking changes, incompatible API changes</major>
        <minor>New features, backwards compatible</minor>
        <patch>Bug fixes, backwards compatible</patch>
      </scheme>
      <examples>
        <example>1.0.0 - Initial release</example>
        <example>1.1.0 - Added new feature</example>
        <example>1.1.1 - Bug fix</example>
        <example>2.0.0 - Breaking API change</example>
      </examples>
    </versioning>

    <release_process>
      <step order="1">Update version number in relevant files</step>
      <step order="2">Update CHANGELOG.md with release notes</step>
      <step order="3">Run full test suite</step>
      <step order="4">Create release commit: "chore: Release v1.2.3"</step>
      <step order="5">Tag the commit: git tag -a v1.2.3 -m "Version 1.2.3"</step>
      <step order="6">Push with tags: git push origin main --tags</step>
      <step order="7">Create GitHub Release (optional)</step>
    </release_process>

    <changelog_format>
      <template>
## [VERSION] - YYYY-MM-DD

### Added
- New features

### Changed
- Changes to existing functionality

### Fixed
- Bug fixes

### Removed
- Removed features

### Security
- Security fixes
      </template>
    </changelog_format>
  </release_management>

  <!-- ============================================================
       PART 7: EMERGENCY PROCEDURES
  ============================================================ -->

  <emergency_procedures>
    <description>
      What to do when things go wrong.
    </description>

    <scenario name="Undo Last Commit (Not Pushed)">
      <command>git reset --soft HEAD~1</command>
      <note>Keeps changes staged, removes commit</note>
    </scenario>

    <scenario name="Undo Last Commit (Already Pushed)">
      <command>git revert HEAD</command>
      <note>Creates new commit that undoes changes - safer than force push</note>
    </scenario>

    <scenario name="Accidentally Pushed Secrets">
      <step order="1">IMMEDIATELY revoke/rotate the exposed credentials</step>
      <step order="2">Remove from code and commit</step>
      <step order="3">Consider using git filter-branch or BFG to remove from history</step>
      <step order="4">Force push (with team notification)</step>
      <step order="5">Add to .gitignore to prevent recurrence</step>
      <warning>Assume the secret is compromised - rotation is mandatory</warning>
    </scenario>

    <scenario name="Wrong Branch">
      <step order="1">git stash (save current changes)</step>
      <step order="2">git checkout correct-branch</step>
      <step order="3">git stash pop (apply changes)</step>
    </scenario>

    <scenario name="Merge Conflict">
      <step order="1">Review conflicted files: git status</step>
      <step order="2">Edit files to resolve conflicts (remove markers)</step>
      <step order="3">Stage resolved files: git add [files]</step>
      <step order="4">Complete merge: git commit</step>
      <rule>Never blindly accept "ours" or "theirs" - review each conflict</rule>
    </scenario>
  </emergency_procedures>

  <!-- ============================================================
       PART 8: GITIGNORE TEMPLATE
  ============================================================ -->

  <gitignore_template>
    <description>
      Recommended .gitignore entries for projects.
    </description>

    <template>
# Dependencies
node_modules/
vendor/
.venv/
__pycache__/
*.pyc

# Build outputs
dist/
build/
*.egg-info/

# Environment & Secrets
.env
.env.local
.env.*.local
*.pem
*.key
credentials.json

# IDE & Editor
.idea/
.vscode/
*.swp
*.swo
*~

# OS Files
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Testing
coverage/
.coverage
.pytest_cache/

# Temporary
tmp/
temp/
*.tmp
    </template>
  </gitignore_template>

</github_publishing>
